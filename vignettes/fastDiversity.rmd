---
title: "Untitled"
author: "Cory"
date: "8/25/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache=T)
```

```{r,message=FALSE}
library(changeRangeR)
library(raster)
library(rasterVis)
library(rgdal)
library(Matrix.utils)
library(tidyverse)
if(Sys.info()["sysname"]== "Windows") library (parallelsugar)
mc.cores=6
```

## Background

>>  Details on computations will be stored in text blocks like this. They can safely be ignored if you're just getting started.

---------------------------------------------------------------

## Set up

<!-- # TMP -->
<!-- # a=read.csv('/Volumes/cm2/changeRangerDemos/trees190/selec/cellIndexTable.csv') -->
<!-- # saveRDS(a,'/Volumes/cm2/changeRangerDemos/trees190/selec/cellIndexTable.rds') -->
<!-- # a=read.csv('/Volumes/cm2/changeRangerDemos/trees190/selec/speciesIndexTable.csv') -->
<!-- # saveRDS(a,'/Volumes/cm2/changeRangerDemos/trees190/selec/speciesIndexTable.rds') -->

### Main Inputs

```{r}
### determine where you want outputs
summaryBaseDir='/Volumes/cm2/changeRangerDemos/trees190_test3'
#summaryBaseDir='/Volumes/cm2/changeRangerDemos/trees190/selec'
if(!file.exists(summaryBaseDir)) dir.create(summaryBaseDir)

# Indicate scenarios. these names will be used throughout to structure folders 
allScen=c('present','8580')
#load environnent with the reprojected projection (typically the one you used for modeling). You only need the raster grid that , not the actual layer values
envGrid=raster::stack(system.file("extdata/treeDemo/envGrid.tif",package='changeRangeR'))

# folder of binary range rasters
myDir=system.file("extdata/treeDemo/BinaryMaps",package='changeRangeR')

# shapefiles for plotting. This one comes preinstallted
world.shp=readOGR(system.file(
  "extdata/treeDemo/TM_WORLD_BORDERS_SIMPL-0.3/TM_WORLD_BORDERS_SIMPL-0.3.shp",
  package='changeRangeR'),'TM_WORLD_BORDERS_SIMPL-0.3',verbose=F)
world.shp2=spTransform(world.shp,projection(envGrid))
```

### Set up directory structure

Set up a standardized set of directory names and structure so that that `changeRanger` functions can access the right files internally. You can specify any optional subdirectories you like, although `changeRanger` will only write outputs there.

```{r}
sumDirs=setupSummaryDirectories(summaryBaseDir, optionalSubDirs=c('funcDiv','phyloDiv'))
str(sumDirs)
```

### Make Sparse Matrices

Begin by converting the range rasters to a matrix with rows indexing cells and columns indexing species.
```{r}
allSpeciesMaps=tibble(rasterFiles=list.files(paste0(myDir,'/present'),
                                             recursive=T, full.names=T)) %>% 
  mutate(sp.names= rasterFiles %>% basename %>% file_path_sans_ext) %>%
  separate(sp.names,into=c('g','sp','t','s'),sep='_') %>% select(-t,-s) %>%
  unite(sp.names,g,sp)
# species index table. columns: species name, integer index
sp.ind=speciesIndexTable(allSpeciesMaps,sumDirs)
# cell Index Table. columns: long, lat, cellid
cell.ind=cellIndexTable(envGrid,nCellChunks=10,sumDirs)

for (scn in allScen){
  allSpeciesMaps=tibble(rasterFiles=list.files(paste0(myDir,'/',scn),
                                               recursive=T, full.names=T)) %>% 
    mutate(sp.names= rasterFiles %>% basename %>% file_path_sans_ext) %>%
    separate(sp.names,into=c('g','sp','t','s'),sep='_') %>% select(-t,-s) %>%
    unite(sp.names,g,sp)
	cellBySpeciesMatrices(sumDirs$cbsDir,
	                      allSpeciesMaps=allSpeciesMaps,
	                      scenario=scn,
	                      envGrid=envGrid,
	                      sp.ind=sp.ind,
                        cell.ind=cell.ind,
	                      nCellChunks=10,
	                      mc.cores=mc.cores,
	                      overwrite=T)
}
# temp solution
# R.utils::copyDirectory(from=system.file('extdata/treeDemo',package='changeRangeR'),
#                        to=sumDirs$sumBaseDir)

```

This step can take a little time, but makes all the downstream steps fast. It converted all the ranges into sparse matrices and stored them in the folder 'CellSpeciesLists'. We refer to these as 'cell by species' matrices, or CBS matrices for short. Depending on file size, or your settings, CBS matrices can be stored in chunks to reduce the need to load in huge files in later operations where you may only need a subset of the chunks. Chunking is done based on rows; that is each contains a subset of cells, but all species. 

Two key outputs are:
  -   cellIndexTable.rds is a matrix where the row indices of the CBS matrices are stored along with the 
  -   speciesIndexTable.rds 

You can see how the globe is broken up into chunks. `sparseToRaster` is also useful to convert anything stored as a sparse matrix back to a raster for spatial operations.

```{r}
cell.ind=readRDS(paste0(sumDirs$myBaseDir,'/cellIndexTable.rds'))
chunks.r=sparseToRaster(cell.ind,envGrid,'chunkID')
plot(chunks.r)
```

---------------------------------------------------------------

## Metrics based only on ranges

In this section we only require that the user provide ranges for each species; auxilary information, such as other environmental layers, traits, or phylogeny is handled in subsequent sections. 

### Total richness

```{r}
rich=lapply(allScen,function(scn){
  r=richnessFromCBS(cbsDir=sumDirs$cbsDir,
                    scenario=scn,env=envGrid,
                    mc.cores=mc.cores, outDir=sumDirs$richDir)
  fdMapPlot(r,paste0(sumDirs$figDir,'/Richness_',scn,'.pdf'),shp=world.shp2)
  r
})

```

>>  **Calculation>>  **: This is calculated based on column sums of the CBS matrix


### Range Size


Range size can be defined in a variety of ways; we define it here as area of occurrence at the native resolution of the SDMS (here ~10km)

```{r}
sp.ind=readRDS(paste0(sumDirs$sumBaseDir,'/speciesIndexTable.rds'))
ra=lapply(allScen,function(scn){
	    rangeArea(cbsDir=sumDirs$cbsDir,scenario=scn,
	              sp.ind=sp.ind,outDir=sumDirs$rangeSizeDir,mc.cores=mc.cores)
})
str(ra)
hist(ra[[1]]$rangeArea)
```

>>  **Calculation>>  **: row sums over CBS matrices.

### Rarity

Here's an example using a 'species attribute', which is a common application. Here we use species attributes to refer to any property of an individual species. Common operations are to (1) summarize species attributes within a spatial unit, or (2) group species based on different values of an attribute and calculate a summary statistic. As an example of (1) we map species rarity (average value of 1/range area over species within a cell).
Here's an example where we add a new place to store outputs, since rarity probably isn't common enough to include as a default.

```{r}
sumDirs$rarityDir=file.path(sumDirs$rangeSizeDir,'Rarity')
if(!file.exists(sumDirs$rarityDir)) dir.create(sumDirs$rarityDir)

rar=lapply(allScen,function(scn){
	# generate the value of 1/range size for each species in an attribute table
	raritySpAttr = sumDirs$rangeSizeDir %>% 
								 list.files(full.names=T,pattern=scn) %>% 
								 readRDS %>% 
								 mutate(rarity=1/rangeArea) %>% 
								 select(-rangeArea)
	r=speciesAttributeByCell(cbsDir=sumDirs$cbsDir,scenario=scn,
	                         attrTable=raritySpAttr, method='mean', 
	                         env=envGrid, outDir=sumDirs$rarityDir)	
	fdMapPlot(log(r),plotFile=paste0(sumDirs$figDir,'/Rarity_',scn,'.pdf'), 
	          shp=world.shp2,legend.args=list(text='log(rarity)',line=2,side=4))
	r
})
rar.st=stack(rar)
```

>>  **Calculation>>  **: Define a 1/range size as a species attribute. Use matrix multiplication of the CBS matrix and species attribute vector.

### Richness by species attributes

Species might have different attributes, like growth form, clade, etc, such that it is useful to split up analyses by group. Here, we'll make a separate richness map for each genus.
```{r}
sumDirs$richByGenusDir=file.path(sumDirs$richDir,'byGenus')
if(!file.exists(sumDirs$richByGenusDir)) dir.create(sumDirs$richByGenusDir)
```

Generate an binary indicator of the genus. Its important that the factors are converted to binary indicators.

```{r}
gen=readRDS(paste0(sumDirs$sumBaseDir, '/speciesIndexTable.rds'))
genusSpAttr = gen %>% select(species) %>%
							separate(species,c("genus",NA),sep='_') %>%
							fastDummies::dummy_cols() %>% 
							bind_cols(gen) %>% select(-genus)
rar=lapply(allScen,function(scn){
	r=richnessFromCBS(cbsDir=sumDirs$cbsDir,scenario=scn,
	                  env=envGrid,mc.cores=mc.cores,
	                  attrTable=genusSpAttr,outDir=sumDirs$richByGenusDir)
	fdMapPlot(r,plotFile=paste0(sumDirs$figDir,'/RichnessByGenus_',scn,'.pdf'), 
	          shp=world.shp2, legend.args=list(text='# species',line=2,side=4))
	r
})
rar.st=stack(rar)
```
 
---------------------------------------------------------------

## Metrics depending on cell attributes

In contrast to species attributes, cells can also have attributes and similarly it is common to (1) summarize cell attributes over species range, or (2) group cells based on different values of an attribute and calculate a summary statistic of the species it contains. A wide variety of analyses can be written in terms of cell attributes: here we classify cells by which ecoregion they occur in. Other possibilities include whether cells are protected, the level of disturbance they have experienced, the level of human impact they have experienced, etc. The key similarity is that each classify every cell into one of a collection of categories.

```{r}
eco=raster(system.file('extdata/treeDemo/GlobalEcoregions.tif',package='changeRangeR'))
# you may need to reproject rasters so that they align with your envGrid
eco2=projectRaster(eco,envGrid,method='ngb')
# mask to australia where there are 28 ecoregions (the masking is slow, so we just read in a stored result from the commented code)
	# aus=getData('GADM', country='AUS', level=0) 
	# aa=sp::spTransform(aus,projection(eco2))
	# ecoAus=raster::mask(eco,aa)
	# writeRaster(ecoAUS,paste0(sumDirs$miscDir,'/aus.tif'),overwrite=T)
ecoAus=raster(system.file('extdata/treeDemo/Misc/aus.tif',package='changeRangeR'))			
```
<!-- # don't need this, i think -->
<!-- # # make a cell attribute table -->
<!-- # cell.ind=readRDS(paste0(sumDirs$myBaseDir,'/cellIndexTable.rds')) -->
<!-- # cellEcoAttr=cell.ind %>%  -->
<!-- #             bind_cols(pr=fastDummies::dummy_cols(ecoAus[cell.ind$cellID])) %>%  -->
<!-- #             select(-'.data',-'.data_NA') -->
<!-- # 	 -->
<!-- # saveRDS(cellEcoAttr,paste0(sumDirs$attrDir,'cellEcoregionAus.rds')) -->

As an example of (1) we find the proportion of each species range in each ecoregion.

```{r}
sp.ind=readRDS(paste0(sumDirs$sumBaseDir, '/speciesIndexTable.rds'))
ecoAus2=projectRaster(ecoAus,envGrid,method='ngb')
# check a few species that occur in australia in this demo
m=mapSpecies(cbsDir=sumDirs$cbsDir,27:30,scenario='present',sp.ind,cell.ind,envGrid)
plot(m)
```


```{r,cache=FALSE}
# TEMP: for some resaon the package doesn't see the correct function
source('/Users/ctg/Dropbox/Projects/Wallace/changeRangeR/R/fdSpecies.r')
# Step 1: get the total number of cells in each species range in each ecoregion
rar=rangeAreaCategoricalRaster(someRaster=ecoAus2,cbsDir=sumDirs$cbsDir,scenario='present',
                               sp.ind=sp.ind,cell.ind=cell.ind,mc.cores=mc.cores)
# Step 2: divide these counts by the total range size to get the proportion of each species range in each ecoregion. 
rap=rangeArea(cbsDir=sumDirs$cbsDir,scenario='present',sp.ind=sp.ind,mc.cores=mc.cores)
# Step 3: join the data frames and calculate proportions
rpbc=rap %>%
  full_join(rar,by=c('species','index')) %>%
  mutate_at(vars(X53:X783), funs(round(./rangeArea,2)))

head(rpbc[27:31,])
```

### Overlay with ecoregions 

As an example of (2) we find the species richness in each ecoregion.

<!-- TODO: need a general function that matches the cellID of envGrid to an new set of IDs defined by a raster with different classes (can rasterize a polygon for an arbitrary polygon). Can also use this for danilo -->

<!-- ## Function to make dictionaries between rasters -->

Sometimes we might want to use rasters based on different characteristics than that the one used for modeling distributions. In that case, we can generate dictionaries between the cellIDs of two rasters, as long as the coordinates of both rasters are compatible.

```{r}
rasterDictionary <- function(r1, r2){
  # This finds the cell where the center of each cell is located. Is that guaranteed to be the cell where the majority of a cell is? 

  coords <- as.data.frame(raster::xyFromCell(r1, 1:ncell(r1)))
  coords$cellID_r1 <- 1:ncell(r1)
  coords$cellID_r2 <- raster::cellFromXY(r2, as.matrix(coords[,1:2]))
  coords[complete.cases(coords),]
}
```

```{r}
dict1 <- rasterDictionary(envGrid, eco)
dict2 <- rasterDictionary(eco, envGrid)
dim(dict1)
length(unique(dict1$cellID_r1))
length(unique(dict1$cellID_r2))
dim(dict2)
length(unique(dict2$cellID_r1))
length(unique(dict2$cellID_r2))
```
```{r}
# Determine which CBS cells are in each group (here, ecoregion)


# Calc richness by group
richnessByFactor=function(cbsDir,cellAttr){
  # 1. split CBS factor
  # 2. colSums within factor
  # 3. convert to binary with vals > 0
  # 4. combine across cbs
  # 5. row sums for richness (or any other operation on these reduced factor by species (FBS) matrices)
  
}
```




>>  **Calculation>>  **:

---------------------------------------------------------------

## Assemblage/Community metrics

Some species attributes depend on which species cooccur with them.

### Find unique communities

TODO what is spCellOcc?

```{r}
uc=lapply(allScen, function(scn){
	makeUniqueCommunities(cbsDir=sumDirs$cbsDir, scenario=scn, mc.cores = mc.cores,overwrite=T)
})
```

>>  **Calculation>>  **: find unique rows of CBS matrices.

### Phylogenetic Diversity 

Phylogenetic diversity is calculated using the PD index (Faith, 1992) and implemented through the function pd.query in the PhyloMeasures package (Tsirogiannis, 2015). The phylogenetic tree was pruned to the species selected from a complete plant phylogeny currently available at Smith et al. (2018). 

<!-- #calculate phylogenetic diversity -->
<!-- # need PDI to standardize for richness -->
<!-- # PD = sum of branch length -->
<!-- # PDI = standardzie by null -->

```{r}
library(PhyloMeasures)
library(ape)
library(tictoc)
phyloTree=read.tree(system.file('extdata/treeDemo/Misc/selecPhyTree.tree',
                    package='changeRangeR'))
sp.ind=readRDS(paste0(sumDirs$sumBaseDir,'/speciesIndexTable.rds'))

#CM: hey pep - why am i getting this warning? 
#  Warning: the input matrix has fewer columns than the number of species in the tree. 

pd=lapply(allScen, function(scn){
  pd1=metricFromCBS(cbsDir=sumDirs$cbsDir,scenario = scn,env = envGrid ,
  	spIndTable=sp.ind, mc.cores = mc.cores,
    #SPECIFY FUCNTION ==> condition, 1st argument of FUNC must be the cellBySp matrix
  	FUN = phyloDiv,outputFUNnames = 'PD',
  	#specify other arguments to pass to FUN
  	fullMatch=F,tree=phyloTree)
  writeRaster(pd1,file=paste0(sumDirs$phyloDivDir,'/PD_',scn,'.tif'),overwrite=T)
  pd1
})

pd = raster::stack(pd)
names(pd) = allScen
plot(pd)
```

### Functional Diversity 

Functional diversity is applied using the same function as the Phylogenetic diversity, but using a dendogram tree based upon imputed values of tree functional traits using BHPMF technique (Schrodt et al. 2015). The functional tree dendogram was finally built with the stats::hclust function from a principal component analysis based on TRY and BIEN databases (see further details in Guo et al. 2020 preprint)
<!-- # 3 metrics: mean distance between all species pairs -->
<!-- # dist of all spceice from community centroid -->
<!-- # hull is not huge -->
<!-- # nearest neightbor -->
<!-- # variance not common -->
<!-- # tree: clustering alg on traits and use phylo metrics on that tree -->
<!-- # functonal uniqueness - cyrille -->
<!-- # functioanl rarity - cyrille -->
<!-- #  -->

```{r}
sp.ind=readRDS(paste0(sumDirs$sumBaseDir,'/speciesIndexTable.rds'))
traitTable=readRDS(system.file('/extdata/treeDemo/speciesAttributes.rds',
                   package='changeRangeR'))
#create a tree of traits based on trait distances (euclidean)
#the fucntion is set up to write the trees and set up rules for the PCA (e.g. how many PC you retain, etc.)
#with writeOut=T it automatically creates the funcDivFolder and writes the "functional tree" there.
trait.phy=buildFuncDivTree(sumDirs = sumDirs,
												   #note here that the func will look for speciesAttributes.rds if NULL
												   #CM: I think the user should have to specify this
													 speciesAttributeTable =traitTable,
													 colFuncTraits = 2:9)

fd=lapply(allScen, function(scn){
  fd1=metricFromCBS(cbsDir=sumDirs$cbsDir,scenario=scn,env=envGrid,
                    spIndTable=sp.ind,
                    mc.cores = mc.cores,
                    #specify function, here `phyloDiv`; 1st argument must be the cellBySp matrix
                    FUN = phyloDiv,outputFUNnames = 'FD',
                    #specify other arguments to pass to FUN
                    fullMatch=F,tree=trait.phy)
})

fd=raster::stack (fd)
names(fd) =  allScen
plot(fd)
```

-------------------------------------------------------------------------

## Changes between scenarios



-------------------------------------------------------------------------

## Some additional utilites

If you want to use the results from a different computer based on the `sumDirs` stored as '.../sumDirs.rds', you'll need to convert the 	`baseDir` to reflect the computer you're working on. Below we convert to my local paths, and then back again.

```{r}
sumDirs=convertSummaryBaseDir(sumDirs, newBaseDir='someDir')
sumDirs=convertSummaryBaseDir(sumDirs, summaryBaseDir) # convert back
```

```{r}
m=mapSpecies(cbsDir=sumDirs$cbsDir,27:30,scenario='present',sp.ind,cell.ind,envGrid)
```


<!-- Ideas
- spatial operations: could use unique communities and just calc comparisons between unique communities that are within a given distance from one another and store that as a sparse matrix. 


-->









-------------------------------------------------------------------------
## References

  - Faith, D.P. 1992. Conservation evaluation and phylogenetic diversity. Biological Conservation 61: 1-10.
  - Tsirogiannis, C. and B. Sandel. 2015. PhyloMeasures: A package for computing phylogenetic biodiversity measures and their statistical moments. Ecography, doi: 10.1111/ecog.01814, 2015.
  - S. A. Smith, J. W. Brown, Constructing a broadly inclusive seed plant phylogeny. Am. J. Bot. 105, 302–314 (2018).
  - F. Schrodt, J. Kattge, H. Shan, F. Fazayeli, J. Joswig, A. Banerjee, M. Reichstein, G. Bönisch, S. Díaz, J. Dickie, A. Gillison, A. Karpatne, S. Lavorel, P. Leadley, C. B. Wirth, I. J. Wright, S. J. Wright, P. B. Reich, BHPMF - a hierarchical Bayesian approach to gap-filling and trait prediction for macroecology and functional biogeography. Glob. Ecol. Biogeogr. 24, 1510–1521 (2015).
  - Wen-Yong Guo, Josep M. Serra-Diaz, Franziska Schrodt, Wolf L. Eiserhardt, Brian S. Maitner, Cory Merow, Cyrille Violle, Madhur Anand, Michaël Belluau, Hans Henrik Bruun, Chaeho Byun, Jane A. Catford, Bruno E. L. Cerabolini, Eduardo Chacón-Madrigal, Daniela Ciccarelli, Johannes H. C. Cornelissen, Anh Tuan Dang-Le, Angel de Frutos, Arildo S. Dias, Aelton B. Giroldo, Kun Guo, Alvaro G. Gutiérrez, Wesley Hattingh, Tianhua He, Peter Hietz, Nate Hough-Snee, Steven Jansen, Jens Kattge, Tamir Klein, Benjamin Komac, Nathan Kraft, Koen Kramer, Sandra Lavorel, Christopher H. Lusk, Adam R. Martin, Maurizio Mencuccini, Sean T. Michaletz, Vanessa Minden, Akira S. Mori, Ülo Niinemets, Yusuke Onoda, Renske E. Onstein, Josep Peñuelas, Valério D. Pillar, Jan Pisek, Bjorn J.M. Robroek, Brandon Schamp, Martjin Slot, Ênio Sosinski, Nadejda A. Soudzilovskaia, Nelson Thiffault, Peter van Bodegom, Fons van der Plas, Ian J. Wright, Wu-Bing Xu, Jingming Zheng, Brian J. Enquist, Jens-Christian Svenning bioRxiv 2020.04.21.052464; doi: 







