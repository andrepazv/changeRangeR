---
title: "Diversity Metrics Using Sparse Matrices"
author: "Cory"
date: "8/25/2020"
output: html_document
vignette: >
  %\VignetteIndexEntry{changeRanger Multispecies examples Lite}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache=T)
```

<!-- ## Background -->

<!-- >>  Details on computations will be stored in text blocks like this. They can safely be ignored if you're just getting started. -->

<!-- --------------------------------------------------------------- -->

## Set up

Pacakges you'll need.

```{r,message=FALSE, warning=FALSE}
library(changeRangeR)
library(raster)
library(rasterVis)
library(rgdal)
library(Matrix.utils)
library(tidyverse)
if(Sys.info()["sysname"]== "Windows") library (parallelsugar)
mc.cores=6
```
### Main Inputs

```{r}
### determine where you want outputs
summaryBaseDir='/Volumes/cm2/changeRangerDemos/trees190_test3'
#summaryBaseDir='/Volumes/cm2/changeRangerDemos/trees190/selec'
if(!file.exists(summaryBaseDir)) dir.create(summaryBaseDir)

# Indicate scenarios. these names will be used throughout to structure folders 
allScen=c('present','8580')
#load environnent with the reprojected projection (typically the one you used for modeling). You only need the raster grid that , not the actual layer values
envGrid=raster::stack(system.file("extdata/treeDemo/envGrid.tif",package='changeRangeR'))

# folder of binary range rasters
myDir=system.file("extdata/treeDemo/BinaryMaps",package='changeRangeR')

# shapefiles for plotting. This one comes preinstallted
world.shp=readOGR(system.file(
  "extdata/treeDemo/TM_WORLD_BORDERS_SIMPL-0.3/TM_WORLD_BORDERS_SIMPL-0.3.shp",
  package='changeRangeR'),'TM_WORLD_BORDERS_SIMPL-0.3',verbose=F)
world.shp2=spTransform(world.shp,projection(envGrid))
```

### Set up directory structure

Set up a standardized set of directory names and structure so that that `changeRanger` functions can access the right files internally. You can specify any optional subdirectories you like, although `changeRanger` will only write outputs there.

```{r}
sumDirs=setupSummaryDirectories(summaryBaseDir, optionalSubDirs=c('funcDiv','phyloDiv'))
str(sumDirs)
```

### Make Sparse Matrices

Begin by converting the range rasters to a matrix with rows indexing cells and columns indexing species. With the `nCellChunks` argument, I'm specifying that the globe should be split up into 10 chunks; this is important when your cell x species matrix is large, because the whole thing can't be read into memory at once. 'Large' will depend on the number of species, the resolution and extent of your maps, and your computer's capabilities. 

```{r message=F}
allSpeciesMaps=tibble(rasterFiles=list.files(paste0(myDir,'/present'),
                                             recursive=T, full.names=T)) %>% 
  mutate(sp.names= rasterFiles %>% basename %>% file_path_sans_ext) %>%
  separate(sp.names,into=c('g','sp','t','s'),sep='_') %>% select(-t,-s) %>%
  unite(sp.names,g,sp)
# species index table. columns: species name, integer index
sp.ind=speciesIndexTable(allSpeciesMaps,sumDirs)
# cell Index Table. columns: long, lat, cellid
cell.ind=cellIndexTable(envGrid,nCellChunks=10,sumDirs)

for (scn in allScen){
  allSpeciesMaps=tibble(rasterFiles=list.files(paste0(myDir,'/',scn),
                                               recursive=T, full.names=T)) %>% 
    mutate(sp.names= rasterFiles %>% basename %>% file_path_sans_ext) %>%
    separate(sp.names,into=c('g','sp','t','s'),sep='_') %>% select(-t,-s) %>%
    unite(sp.names,g,sp)
  cellBySpeciesMatrices(sumDirs$cbsDir,
	                      allSpeciesMaps=allSpeciesMaps,
	                      scenario=scn,
	                      envGrid=envGrid,
	                      sp.ind=sp.ind,
                        cell.ind=cell.ind,
	                      nCellChunks=10,
	                      mc.cores=mc.cores,
	                      overwrite=T)
}
```

This step can take a little time, but makes all the downstream steps fast. It converted all the ranges into sparse matrices and stored them in the folder 'CellSpeciesLists'. We refer to these as 'cell by species' matrices, or CBS matrices for short. Depending on file size, or your settings, CBS matrices can be stored in chunks to reduce the need to load in huge files in later operations where you may only need a subset of the chunks. Chunking is done based on rows; that is each contains a subset of cells, but all species. 

Two key outputs are:

  -   cellIndexTable.rds is a data frame where the row indices of the CBS matrices are stored along with the coordinates and cellIDs of your environmental grid.
  -   speciesIndexTable.rds is a data frame where the column indices of the CBS matrices are stored along with species names.

As we develop more complex analyses with auxilary data, we'll add 'cell attributes' and 'species attributes' to these data frames, respectively, that will allow us to generate a wide range of summaries.

```{r}
cell.ind=readRDS(paste0(sumDirs$myBaseDir,'/cellIndexTable.rds'))
head(cell.ind)
```

```{r}
sp.ind=readRDS(paste0(sumDirs$myBaseDir,'/speciesIndexTable.rds'))
head(sp.ind)
```

You can see how the globe is broken up into chunks. `sparseToRaster` is also useful to convert anything stored as a sparse matrix back to a raster for spatial operations.

```{r}
cell.ind=readRDS(paste0(sumDirs$myBaseDir,'/cellIndexTable.rds'))
chunks.r=sparseToRaster(cell.ind,envGrid,'chunkID')
fdMapPlot(chunks.r,shp=world.shp2)
```

---------------------------------------------------------------

## Metrics based only on ranges

In this section we only require that the user provide ranges for each species; auxilary information, such as other environmental layers, traits, or phylogeny is handled in subsequent sections. 

### Total richness

```{r}
rich=lapply(allScen,function(scn){
  r=richnessFromCBS(cbsDir=sumDirs$cbsDir,
                    scenario=scn,env=envGrid,
                    mc.cores=mc.cores, outDir=sumDirs$richDir)
  fdMapPlot(r,paste0(sumDirs$figDir,'/Richness_',scn,'.pdf'),shp=world.shp2)
  r
})
fdMapPlot(rich[[1]],shp=world.shp2)
```

>>  **Calculation**: This is calculated based on column sums of the CBS matrix

### Range Size

Range size can be defined in a variety of ways; we define it here as area of occurrence at the native resolution of the SDMS (here ~10km)

```{r}
sp.ind=readRDS(paste0(sumDirs$sumBaseDir,'/speciesIndexTable.rds'))
ra=lapply(allScen,function(scn){
	    rangeArea(cbsDir=sumDirs$cbsDir,scenario=scn,
	              sp.ind=sp.ind,outDir=sumDirs$rangeSizeDir,mc.cores=mc.cores)
})
str(ra)
hist(ra[[1]]$rangeArea)
```

>>  **Calculation**: row sums over CBS matrices.

### Rarity

Here's an example using a 'species attribute', which is a common application. Here we use species attributes to refer to any property of an individual species. Common operations are to (1) summarize species attributes within a spatial unit, or (2) group species based on different values of an attribute and calculate a summary statistic. As an example of (1) we map species rarity (average value of 1/range area over species within a cell).
Here's an example where we add a new place to store outputs, since rarity probably isn't common enough to include as a default.

```{r}
sumDirs$rarityDir=file.path(sumDirs$rangeSizeDir,'Rarity')
if(!file.exists(sumDirs$rarityDir)) dir.create(sumDirs$rarityDir)

rar=lapply(allScen,function(scn){
	# generate the value of 1/range size for each species in an attribute table
	raritySpAttr=sumDirs$rangeSizeDir %>% 
	  list.files(full.names=T,pattern=scn) %>% 
	  readRDS %>% 
	  mutate(rarity=1/rangeArea) %>% 
	  select(-rangeArea)
	r=speciesAttributeByCell(cbsDir=sumDirs$cbsDir,scenario=scn,
	                         attrTable=raritySpAttr, method='mean', 
	                         env=envGrid, outDir=sumDirs$rarityDir)	
	fdMapPlot(log(r),plotFile=paste0(sumDirs$figDir,'/Rarity_',scn,'.pdf'), 
	          shp=world.shp2,legend.args=list(text='log(rarity)',line=2,side=4))
	r
})
rar.st=stack(rar)
fdMapPlot(log(rar.st[[1]]),shp=world.shp2,legend.args=list(text='log(rarity)'))
```
