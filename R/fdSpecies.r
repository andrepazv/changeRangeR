#===================================================================
#===================================================================
#===================================================================
#' @export

# species index table
	# columns: species name, integer index
speciesIndexTable=function(allSpeciesMaps,sumDirs){
	# old way with lists
	#sp.ind=data.frame(species=unique(unlist(inputsFromSDMWorkflow$sp.names, recursive=T)))
	sp.ind=data.frame(species=allSpeciesMaps$sp.names)
	sp.ind$index=1:nrow(sp.ind)
	write.csv(sp.ind,file=paste0(sumDirs$sumBaseDir,'/speciesIndexTable.csv'), row.names=F)
	sp.ind
}

#===================================================================
#===================================================================
#===================================================================

#' @export
richnessFromCBS=function(cbsDir,scenario,env,mc.cores,verbose=F){
	cbs.f=list.files(paste0(cbsDir,'/',scenario),full.names=T)
	toss=grep('temp_',cbs.f)
	cbs.f=cbs.f[-toss]
	richByCell=parallel::mclapply(seq_along(cbs.f), function(x){
		if(verbose) message(x)
		cbs=readRDS(cbs.f[x])
		a=data.frame(cellID=as.numeric(rownames(cbs)),
		           rich=textTinyR::sparse_Sums(cbs, rowSums = T))
	},mc.cores=mc.cores)
	rich.vec=do.call('rbind',richByCell)
	rich.r=raster(env[[1]])
	values(rich.r)[rich.vec$cellID]= rich.vec$rich
	rich.r
}

#===================================================================
#===================================================================
#===================================================================
#' @notes optionally uses an attribute table to subset by each column not called `species` or `index` and creates a richness file based on the name of the attribute table column. the attribute table must include the species and index columns, as generated by `speciesIndexTable`
#' @export
richnessFromCBSAttr=function(cbsDir,
														 scenario,
														 env,
														 mc.cores,
														 attrTable=NULL,
														 outFileBase=NULL,
														 verbose=F){
	cbs.f=list.files(paste0(cbsDir,'/',scenario),full.names=T)
	toss=grep('temp_long',cbs.f)
	cbs.f=cbs.f[-toss]
	attrNames=names(attrTable)
	# if species and index were included, toss them
	toss=unlist(mapply(function(x){grep(x,attrNames)}, c('species','index')))
	if(length(toss) > 0 ) attrNames=attrNames[-toss]

	out=lapply(seq_along(attrNames),function(y){
		if(verbose) message(attrNames[y])
		keep=attrTable$index[attrTable[attrNames[y]]==1]
		richByCell=mclapply(seq_along(cbs.f), function(x){
		  if(verbose) message(x)
			cbs.tmp=readRDS(cbs.f[x])
			cbs=cbs.tmp[,keep]
			#fuck=data.frame(spID=as.numeric(colnames(cbs)),rich=textTinyR:: sparse_Sums(cbs, rowSums = F))
			#print(fuck[fuck[,2]>0,])
			data.frame(cellID=as.numeric(rownames(cbs)),rich=textTinyR:: sparse_Sums(cbs, rowSums = T))
		},mc.cores=mc.cores)
		rich.vec=do.call('rbind',richByCell)
		rich.r=env[[1]]
		values(rich.r)=NA
		values(rich.r)[rich.vec$cellID]= rich.vec$rich
		if(!is.null(outFileBase))		writeRaster(rich.r,file=paste0(outFileBase,'/', attrNames[y],'.tif'), overwrite=T)
		rich.r
	})
	out1=stack(out)
	names(out1)=attrNames
  out1
}

#===================================================================
#===================================================================
#===================================================================
#' @notes Units of range area are number of pixels
#' @export
rangeArea=function(cbsDir,outDir=NULL,scenario,sp.ind,verbose=F){
	cbs.f=list.files(paste0(cbsDir,'/',scenario),full.names=T)
	toss=grep('temp_',cbs.f)
	cbs.f=cbs.f[-toss]
	rangeSize.tmp=mclapply(seq_along(cbs.f),function(x){
	  if(verbose) message(x)
		cbs=readRDS(cbs.f[x])
		data.frame(rich=textTinyR::sparse_Sums(cbs, rowSums = F))
	},mc.cores=mc.cores)
		# assumes the columns line up perfectly
	rangeSize=data.frame(sp.ind,rangeArea=apply(do.call('cbind', rangeSize.tmp), 1,sum))
	if(!is.null(outDir)) saveRDS(rangeSize,file=paste0(outDir,'/RangeSize_',scenario, '.rds'))
	# check against base range maps (leaving this here in case we find a need)
	# checkVsRangeMaps=F
	# 	if(scenario=='Present' & checkVsRangeMaps){
	# 		range.f=list.files( '/Users/ctg/Documents/SDMs/BIEN41/NWPlants_BinaryOnly/BIEN41_outputs/PPM/BinaryMaps',full.names=T,recursive=T,pattern='TP05')
	# 		keep=sample(seq_along(range.f),50)
	# 		out=mclapply(seq_along(keep),function(x){
	# 			r=raster(range.f[keep[x]])
	# 			true=cellStats(r,sum,na.rm=T)
	# 			sp=strsplit(tools::file_path_sans_ext(basename(range.f[keep[x]])), '__')[[1]][2]
	# 			keep1=grep(sp, rangeSize$species)
	# 			print(x)
	# 			data.frame(sp=sp,true=true,cbsRangesize=rangeSize[keep1,3])
	# 		},mc.cores=5)
	# 		(out1=do.call(rbind,out))
	# 	}
	rangeSize
}


#===================================================================
#===================================================================
#===================================================================
#' @export
rangeAreaInBinaryStack=function(someRaster,cbsDir,sp.ind,cell.ind,mc.cores=1){
	cbs.f=list.files(paste0(cbsDir,'/',scenario),full.names=T)
	toss=grep('temp_',cbs.f)
	cbs.f=cbs.f[-toss]
	rangeSize.tmp=mclapply(seq_along(cbs.f),function(x){
		message(x)
		cbs=readRDS(cbs.f[x])
		keep=	which(cell.ind$cellID %in% as.numeric(dimnames(cbs)[[1]]) )
		keep1=cell.ind$cellID[keep]
		someRaster.mat=matrix(values(someRaster),ncol=nlayers(someRaster))[keep1,] #matrix(values(someRaster),ncol=1)[keep1,] # for 1 layer
		someRaster.mat[is.na(someRaster.mat)]=0
		out=t(cbs) %*% someRaster.mat
	},mc.cores=mc.cores)
	out=Reduce('+',rangeSize.tmp) %>% as.matrix %>% as.data.frame
	names(out)=names(someRaster)
	out=data.frame(sp.ind,out)
			# assumes the columns line up perfectly
	#aa=data.frame(rangeSize=apply(do.call('cbind', rangeSize.tmp), 1,sum))  # for 1 layer
# 	all.rs.burned.by.year=data.frame(do.call('cbind', lapply(1:ncol(rangeSize.tmp[[1]]),function(x){
# 			thisScen=do.call('cbind',lapply(rangeSize.tmp,function(y) y[[x]]))
# 			apply(thisScen,1,sum)
# 		})))
# 	names(all.rs.burned.by.year)=names(someRaster)#basename(ba.f)
	out
}

# different version i can probably toss
# # #for(i in 1:length(inputsFromSDMWorkflow$scenarios)){
# # #	scenario=inputsFromSDMWorkflow$scenarios[i]
# # #	print(scenario)
# # 	scenario="Present"
# # 	cbs.f=list.files(paste0(sumDirs$cbsDir,'/',scenario),full.names=T)
# # 	toss=grep('temp_',cbs.f)
# # 	cbs.f=cbs.f[-toss]
# # 	rangeSizeBurned.tmp=mclapply(seq_along(cbs.f),function(x){
# # 		message(x)
# # 		cbs=readRDS(cbs.f[x])
# # 		# subset to just the cells in this chunk
# # 		# this should work, but sometimes a cell is missing
# # 		# burn.sub=burn.val[cell.ind$cellID[cell.ind$chunkID==x],]
# # 		burn.sub=burn.val[as.numeric(dimnames(cbs)[[1]]),]
# # 		t(cbs) %*% burn.sub
# # 	},mc.cores=mc.cores)
# # 	out=Reduce('+',rangeSizeBurned.tmp) %>% as.matrix %>% as.data.frame
# # 		# assumes the columns line up perfectly
# # 	rangeSizeBurned=data.frame(sp.ind,out)
# #
# # 	rangeSizeOutDir=paste0(summaryBaseDir,'/RangeSize')
# # 	if(!file.exists(rangeSizeOutDir)) dir.create(rangeSizeOutDir)
# # 	saveRDS(rangeSizeBurned, file=paste0(rangeSizeOutDir,'/RangeSizeBurnt_',scenario,version,'.rds'))
# # #}

#===================================================================
#===================================================================
#===================================================================

#' @description For use with a single categorical raster
#' @export
rangeAreaRaster=function(someRaster,catNames,cbsDir,sp.ind,cell.ind, mc.cores=1){

	cats=sort(na.omit(unique(values(someRaster))))
	someRaster2=layerize(someRaster)
	names(someRaster2)=catNames
	out=rangeAreaInBinaryStack(someRaster2,cbsDir=cbsDir,sp.ind=sp.ind, cell.ind=cell.ind,mc.cores=mc.cores)
	out
}

#===================================================================
#===================================================================
#===================================================================

# DONT USE THIS; IT IS REPLACED BY rangeAreaInBinaryStack
#' @export
# subsetRangeByCellProportion=function(someRaster,cbs.f,cell.ind,mc.cores=1){
# 	rangeSize.tmp=mclapply(seq_along(cbs.f),function(x){
# 		cbs=readRDS(cbs.f[x])
# 		keep=	which(cell.ind$cellID %in% cbs@Dimnames[[1]] )
# 		keep1=cell.ind$cellID[keep]
# 		someRaster.mat=matrix(values(someRaster),ncol=nlayers(someRaster))[keep1,] #matrix(values(someRaster),ncol=1)[keep1,] # for 1 layer
# 		someRaster.mat[is.na(someRaster.mat)]=0
# 		out=t(cbs) %*% someRaster.mat
# 		message(x)
# 		tmp=data.frame(as.matrix(out))
# 		names(tmp)=names(someRaster)
# 		tmp
# 	},mc.cores=mc.cores)
# 			# assumes the columns line up perfectly
# 	#aa=data.frame(rangeSize=apply(do.call('cbind', rangeSize.tmp), 1,sum))  # for 1 layer
# 	all.rs.burned.by.year=data.frame(do.call('cbind', lapply(1:ncol(rangeSize.tmp[[1]]),function(x){
# 			thisScen=do.call('cbind',lapply(rangeSize.tmp,function(y) y[[x]]))
# 			apply(thisScen,1,sum)
# 		})))
# 	names(all.rs.burned.by.year)=names(someRaster)#basename(ba.f)
# 	all.rs.burned.by.year
# }


